using Identity.Infrastructure.Models;
using Identity.Infrastructure.Services.Interfaces;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using System.Security.Cryptography;

namespace Identity.Infrastructure.Services
{
    // TODO:
    // Add file encryption/decryption with autogenerated codes
    // for increased key security.

    public class KeyManager : IKeyManager
    {
        private readonly string _keyDirectory;
        private readonly AsyncLazy<RSA> _rsaKeyPairLazy; // Contains both private and public keys - If you were confused like me :)
        private readonly AsyncLazy<byte[]> _hmacLazy; // Not in use for this project but nice to have.
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1); // Used for thread locking

        public KeyManager(string keyDirectory)
        {
            _keyDirectory = keyDirectory;
            _rsaKeyPairLazy = new AsyncLazy<RSA>(() => LoadOrCreateKeyAsync<RSA>("RSAKey.json"));
            _hmacLazy = new AsyncLazy<byte[]>(() => LoadOrCreateKeyAsync<byte[]>("HMACKey.json"));
        }

        public Task<RSA> RsaKeyPairAsync => _rsaKeyPairLazy.Value;
        public Task<byte[]> HmacKeyAsync => _hmacLazy.Value;

        public async Task<RsaSecurityKey> GetPrivateRsaKeyAsync()
        {
            RSA? rsaKey = await RsaKeyPairAsync;

            if (rsaKey != null)
                return new RsaSecurityKey(rsaKey); // This represents the private key (used for signing)
            else
                throw new InvalidOperationException("RSA key pair is null.");
        }

        public async Task<RsaSecurityKey> GetPublicRsaKeyAsync()
        {
            RSA? rsaKey = await RsaKeyPairAsync;

            if (rsaKey != null)
                return new RsaSecurityKey(rsaKey.ExportParameters(false)); // This represents the public key (used for verifying)
            else
                throw new InvalidOperationException("RSA key pair is null.");
        }

        private async Task<T> LoadOrCreateKeyAsync<T>(string keyFileName)
        {
            await _semaphore.WaitAsync();
            try
            {
                string filePath = Path.Combine(_keyDirectory, keyFileName);

                // Ensure the directory structure exists
                string directoryPath = Path.GetDirectoryName(filePath) ?? throw new InvalidOperationException("No path was provided");
                if(directoryPath != null)
                    Directory.CreateDirectory(directoryPath);

                if (File.Exists(filePath))
                {
                    string keyData = await File.ReadAllTextAsync(filePath);
                    var key = JsonConvert.DeserializeObject<T>(keyData);

                    return key == null ? throw new InvalidOperationException("Key data is null.") : key;
                }
                else
                {
                    // Generate a new key and save it to the JSON file
                    T newKey = GenerateRandomKey<T>();
                    string keyData = JsonConvert.SerializeObject(newKey);
                    await File.WriteAllTextAsync(filePath, keyData);
                    return newKey;
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to load or create {typeof(T).Name} key.", ex);
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private static T GenerateRandomKey<T>()
        {
            if (typeof(T) == typeof(byte[]))
            {
                // Generate a random byte array for HMAC key
                var hmacKey = new byte[64];
                using (var rng = RandomNumberGenerator.Create())
                {
                    rng.GetBytes(hmacKey);
                }
                return (T)(object)hmacKey;
            }
            else if (typeof(T) == typeof(RSA))
            {
                // Generate a new RSA key pair
                using RSA rsa = RSA.Create();
                return (T)(object)rsa;
            }
            else
            {
                throw new NotSupportedException($"Key generation for type {typeof(T)} is not supported.");
            }
        }
    }
}
