using Identity.Infrastructure.Models;
using Identity.Infrastructure.Services.Interfaces;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using System.Security.Cryptography;

namespace Identity.Infrastructure.Services
{
    // TODO:
    // Add file encryption/decryption with autogenerated codes
    // for increased key security.

    public class KeyManager : IKeyManager
    {
        private readonly string _keyDirectory;
        private readonly AsyncLazy<RSAParameters> _publicRsaKeyParametersLazy;
        private readonly AsyncLazy<RSAParameters> _privateRsaKeyParametersLazy;
        private readonly AsyncLazy<byte[]> _hmacLazy;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

        public KeyManager(string keyDirectory)
        {
            _keyDirectory = keyDirectory;
            _publicRsaKeyParametersLazy = new AsyncLazy<RSAParameters>(() => LoadOrCreateKeyAsync<RSAParameters>("PublicRSAKey.json", false));
            _privateRsaKeyParametersLazy = new AsyncLazy<RSAParameters>(() => LoadOrCreateKeyAsync<RSAParameters>("PrivateRSAKey.json", true));
            _hmacLazy = new AsyncLazy<byte[]>(() => LoadOrCreateKeyAsync<byte[]>("HMACKey.json"));
        }

        public Task<RSAParameters> PublicRsaKeyParametersAsync => _publicRsaKeyParametersLazy.Value;
        public Task<RSAParameters> PrivateRsaKeyParametersAsync => _privateRsaKeyParametersLazy.Value;
        public Task<byte[]> HmacKeyAsync => _hmacLazy.Value;

        public async Task<RsaSecurityKey> GetPublicRsaSecurityKeyAsync()
        {
            RSAParameters rsaParameters = await PublicRsaKeyParametersAsync;
            return new RsaSecurityKey(rsaParameters);
        }

        public async Task<RsaSecurityKey> GetPrivateRsaSecurityKeyAsync()
        {
            RSAParameters rsaParameters = await PrivateRsaKeyParametersAsync;
            RSA rsa = RSA.Create();
            rsa.ImportParameters(rsaParameters);
            return new RsaSecurityKey(rsa);
        }

        private async Task<T> LoadOrCreateKeyAsync<T>(string keyFileName, bool includePrivateParameters = false)
        {
            await _semaphore.WaitAsync();
            try
            {
                string filePath = Path.Combine(_keyDirectory, keyFileName);
                string directoryPath = Path.GetDirectoryName(filePath) ?? throw new InvalidOperationException("No path was provided");
                if (directoryPath != null)
                    Directory.CreateDirectory(directoryPath);

                if (File.Exists(filePath))
                {
                    string keyData = await File.ReadAllTextAsync(filePath);
                    var key = JsonConvert.DeserializeObject<T>(keyData);
                    return key ?? throw new InvalidOperationException("Key data is null.");
                }
                else
                {
                    T newKey = GenerateRandomKey<T>(includePrivateParameters);
                    string keyData = JsonConvert.SerializeObject(newKey);
                    await File.WriteAllTextAsync(filePath, keyData);
                    return newKey;
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to load or create {typeof(T).Name} key.", ex);
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private static T GenerateRandomKey<T>(bool includePrivateParameters = false)
        {
            if (typeof(T) == typeof(byte[]))
            {
                // HMAC key generation
                var hmacKey = new byte[64];
                using (var rng = RandomNumberGenerator.Create())
                {
                    rng.GetBytes(hmacKey);
                }
                return (T)(object)hmacKey;
            }
            else if (typeof(T) == typeof(RSAParameters))
            {
                // RSA key generation
                using RSA rsa = RSA.Create();
                return (T)(object)rsa.ExportParameters(includePrivateParameters);
            }
            else
            {
                throw new NotSupportedException($"Key generation for type {typeof(T)} is not supported.");
            }
        }
    }
}
